"""generate_graphs

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10RZQvG8ndF8Jytl7iysfOnX318rQvBKA
"""

import os
from PIL import Image
from datetime import datetime
from app.models import Patient

# Define the electrode to region mapping (same as before)
electrode_to_region = {
    "RAM": "Temporal",
    "RAH": "Temporal",
    "RMH": "Temporal",
    "RPH": "Temporal",
    "ROF": "Frontal",
    "RAC": "Frontal",
    "RPC": "Parietal",
    "RAI": "Insula",
    "RMI": "Insula",
    "RPI": "Insula",
    "LAM": "Temporal",
    "LAH": "Temporal",
    "LMH": "Temporal",
    "LPH": "Temporal",
    "LOF": "Frontal",
    "LAC": "Frontal",
    "LPC": "Parietal",
    "LAI": "Insula",
    "LMI": "Insula",
    "LPI": "Insula",
    "LOC": "Occipital",
    "LSP": "Occipital",
    "RSA": "Frontal",
    "RSL": "Frontal",
    "RSP": "Occipital",
    "RSF": "Frontal",
    "RFO": "Frontal",
    "RSI": "Frontal",
    "RPOSTC": "Somatosensory",
    "RPREC": "Motor Cortex",
    "RSMA": "Motor Cortex",
    "FP": "Frontal",
    "F": "Frontal",
    "T": "Temporal",
    "O": "Occipital",
    "C": "Central",
    "P": "Parietal",
    "FZ": "Frontal",
    "CZ": "Central",
    "PZ": "Parietal",
}

eeg_montage_set = {
    ("RAM", "Right Amygdala"),
    ("RAH", "Right Anterior Hippocampus"),
    ("RMH", "Right Middle Hippocampus"),
    ("RPH", "Right Posterior Hippocampus"),
    ("ROF", "Right Orbitofrontal"),
    ("RAC", "Right Anterior Cingulate"),
    ("RPC", "Right Posterior Cingulate"),
    ("RAI", "Right Anterior Insula"),
    ("RMI", "Right Middle Insula"),
    ("RPI", "Right Posterior Insula"),
    ("LAM", "Left Amygdala"),
    ("LAH", "Left Anterior Hippocampus"),
    ("LMH", "Left Middle Hippocampus"),
    ("LPH", "Left Posterior Hippocampus"),
    ("LOF", "Left Orbitofrontal"),
    ("LAC", "Left Anterior Cingulate"),
    ("LPC", "Left Posterior Cingulate"),
    ("LAI", "Left Anterior Insula"),
    ("LMI", "Left Middle Insula"),
    ("LPI", "Left Posterior Insula"),
    ("LOC", "Left Occipital"),
    ("LSP", "Left SPECT Posterior (mirror)"),
    ("RSA", "Right SPECT Anterior"),
    ("RSL", "Right SPECT Lateral"),
    ("RSP", "Right SPECT Posterior"),
    ("RSF", "Right SPECT Frontal"),
    ("RFO", "Right Frontal Operculum"),
    ("RSI", "Right SPECT Inferior"),
    ("RPOSTC", "Right Post-Central Gyrus"),
    ("RPREC", "Right Pre-Central Gyrus"),
    ("RSMA", "Right Supplementary Motor Area"),
    ("FP", "Frontal Pole"),
    ("F", "Frontal"),
    ("T", "Temporal"),
    ("O", "Occipital"),
    ("C", "Central"),
    ("P", "Parietal"),
    ("FZ", "Frontal Midline"),
    ("CZ", "Central Midline"),
    ("PZ", "Parietal Midline"),
}

# data1 = [

#   {
#     "seizure_onset_electrodes": [
#       "RMH1",
#       "RMH2",
#       "LAH2",
#       "LAH3",
#       "LAH4",
#       "LAH5"
#     ],
#     "seizure_time": "06:48:00",
#     "duration": 60,
#     "day": 2
#   },
#   {
#     "seizure_onset_electrodes": [
#       "RMH1",
#       "RMH2",
#       "RMH3",
#       "RMH4",
#       "LAH2",
#       "LAH3",
#       "LAH4",
#       "LAH5"
#     ],
#     "seizure_time": "08:11:00",
#     "duration": 90,
#     "day": 2
#   },
#     {
#     "seizure_onset_electrodes": [
#       "RMH1",
#       "RMH2",
#       "LAH2",
#       "LAH3",
#       "LAH4",
#       "LAH5"
#     ],
#     "seizure_time": "06:48:00",
#     "duration": 60,
#     "day": 7
#   },
#   {
#     "seizure_onset_electrodes": [
#       "RMH1",
#       "RMH2",
#       "RMH3",
#       "RMH4",
#       "LAH2",
#       "LAH3",
#       "LAH4",
#       "LAH5"
#     ],
#     "seizure_time": "08:11:00",
#     "duration": 90,
#     "day": 7
#   }
# ]

# data2 = [
#   {
#     "name": "onfi",
#     "time": "22:00:00",
#     "day": 1,
#     "mg_administered": "10"
#   },
#   {
#     "name": "vimpat",
#     "time": "08:00:00",
#     "day": 1,
#     "mg_administered": "200"
#   },
#   {
#     "name": "vimpat",
#     "time": "20:00:00",
#     "day": 1,
#     "mg_administered": "200"
#   },
#   {
#     "name": "tpm",
#     "time": "08:00:00",
#     "day": 1,
#     "mg_administered": "200"
#   },
#   {
#     "name": "tpm",
#     "time": "20:00:00",
#     "day": 2,
#     "mg_administered": "200"
#   },
#   {
#     "name": "lamotrigine",
#     "time": "08:00:00",
#     "day": 2,
#     "mg_administered": "250"
#   },
#   {
#     "name": "lamotrigine",
#     "time": "20:00:00",
#     "day": 2,
#     "mg_administered": "250"
#   },
#   {
#     "name": "bang",
#     "time": "20:00:00",
#     "day": 2,
#     "mg_administered": "250"
#   },
#   {
#     "name": "blot",
#     "time": "20:00:00",
#     "day": 2,
#     "mg_administered": "250"
#   },
#   {
#     "name": "brrp",
#     "time": "20:00:00",
#     "day": 2,
#     "mg_administered": "250"
#   },
#   {
#     "name": "boop",
#     "time": "20:00:00",
#     "day": 2,
#     "mg_administered": "240"
#   }
# ]


# """
# - seizure length
# - seizure day
# - clinical/subclinical -> represented by rectangle vs 1/2 rectangle
# - seizure onset electrodes -> represented by proximity heatmap
# - seizure drug administration -> represented by color bars below the x axis
# -

# """
# """
# screen 1
# """
# #optional clinical/subclinical
# #optional soz zones heatmap - make color key for every electrode ever

#   #case seizures per day
#   #case seizures with length per day


# """
# screen2 -> duration by time
# """

# #optional clinical/subclinical -> rectangle size
# #optional soz zones heatmap - make color key for every electrode ever
# #optional seizure drug administration bar -> other y axis for drugs mg administered

#   #case seizures per day per time
#   #case seizures with length per day per time


# """
# screen3 -> seizure onset electrodes by seizure
# """
# #optional clinical/subclinical
# #case seizure onset electrodes by seizure

from PIL import Image, ImageDraw
from datetime import datetime
import matplotlib.pyplot as plt
import numpy as np
from collections import defaultdict
from matplotlib.ticker import MaxNLocator
import matplotlib.patches as mpatches
from io import BytesIO

# Your data1 and data2 remain unchanged


def make_plot2(
    screen: int,
    view_seizure_length: int,
    view_soz_heatmap: int,
    view_drug_admin: int,
    seizure_data,
    drug_data,
) -> Image.Image:
    """
    Generate a plot based on the specified screen and optional views.

    Parameters:
    - screen: int, the screen to display (1, 2, or 3)
    - view_seizure_length: int, whether to show seizure length representation (0 or 1)
    - view_soz_heatmap: int, whether to show seizure onset zone heatmap (0 or 1)
    - view_drug_admin: int, whether to show drug administration bars (0 or 1)

    Returns:
    - Image.Image, the generated plot as an image
    """

    # Create a blank image
    img = Image.new("RGB", (800, 600), color="white")
    draw = ImageDraw.Draw(img)

    # Data for seizures and drug administration
    seizures = seizure_data

    # Extract seizure onset electrodes from data1
    seizure_onset_electrodes = set()
    for seizure in seizures:
        seizure_onset_electrodes.update(seizure["electrodes"])

    drugs = drug_data
    

    # Calculate the range of days in the data
    seizure_days = [seizure["day"] for seizure in seizures]
    max_day = (
        max(seizure_days) if seizure_days else 1
    )  # Default to 1 if no seizures
    all_days = range(1, max_day + 1)  # Always start from Day 1

    # Set figure size and font sizes for iPhone 16 screen
    plt.rcParams.update({"font.size": 12})
    figsize = (4, 6)  # Adjusted figure size for iPhone 16 screen

    seizure_event = defaultdict()
    seizure_event["sorted_seizure_onset_electrodes"] = sort_electrodes(
        seizure_onset_electrodes
    )
    cases = 0
    if (len(seizure_event["sorted_seizure_onset_electrodes"]["center"])) == 0:
        cases = cases + 1
    if (len(seizure_event["sorted_seizure_onset_electrodes"]["right"])) == 0:
        cases = cases + 2
    if (len(seizure_event["sorted_seizure_onset_electrodes"]["left"])) == 0:
        cases = cases + 4

    if cases == 0:
        colors = get_red_green_blue_groups(
            len(seizure_event["sorted_seizure_onset_electrodes"]["right"]),
            len(seizure_event["sorted_seizure_onset_electrodes"]["center"]),
            len(seizure_event["sorted_seizure_onset_electrodes"]["left"]),
        )
    if cases == 3:
        colors = get_max_separated_colors(
            len(seizure_event["sorted_seizure_onset_electrodes"]["left"])
        )

    if cases == 5:
        colors = get_max_separated_colors(
            len(seizure_event["sorted_seizure_onset_electrodes"]["right"])
        )

    if cases == 6:
        colors = get_max_separated_colors(
            len(seizure_event["sorted_seizure_onset_electrodes"]["center"])
        )

    if cases == 1:

        colors = get_red_blue_groups(
            len(seizure_event["sorted_seizure_onset_electrodes"]["right"]),
            len(seizure_event["sorted_seizure_onset_electrodes"]["left"]),
        )

    if cases == 2:
        colors = get_max_separated_colors(
            len(seizure_event["sorted_seizure_onset_electrodes"]["right"])
        )
        colors = get_red_blue_groups(
            len(seizure_event["sorted_seizure_onset_electrodes"]["center"]),
            len(seizure_event["sorted_seizure_onset_electrodes"]["left"]),
        )
    if cases == 4:
        colors = get_red_blue_groups(
            len(seizure_event["sorted_seizure_onset_electrodes"]["right"]),
            len(seizure_event["sorted_seizure_onset_electrodes"]["center"]),
        )

    sorted_electrodes = (
        [e for e in seizure_event["sorted_seizure_onset_electrodes"]["right"]]
        + [
            e
            for e in seizure_event["sorted_seizure_onset_electrodes"]["center"]
        ]
        + [e for e in seizure_event["sorted_seizure_onset_electrodes"]["left"]]
    )

    color_electrode_map = list(zip(colors, sorted_electrodes))
    electrode_to_color = {label: color for color, label in color_electrode_map}
    if screen == 1:
        # Group seizures by day
        day_to_seizures = defaultdict(list)
        for seizure in seizures:
            day_to_seizures[seizure["day"]].append(seizure)

        # Create a stacked bar plot
        fig = plt.figure(figsize=figsize)
        bottoms = [0] * len(all_days)  # Initialize bottoms for stacking
        bar_color = "skyblue"  # Set a uniform color for the bars
        edge_color = "black"  # Set the color of the outline

        if view_seizure_length == 0 and view_soz_heatmap == 0:
            seizure_counts = [len(day_to_seizures[day]) for day in all_days]
            plt.bar(
                all_days,
                seizure_counts,
                color="skyblue",
                label="Number of Seizures",
            )
            plt.xlabel("Day", fontsize=14)
            plt.ylabel("Number of Seizures", fontsize=14)
            plt.title("Seizure Count by Day", fontsize=12)
            plt.xticks(all_days, fontsize=12)
            plt.yticks(fontsize=12)
            plt.gca().yaxis.set_major_locator(
                MaxNLocator(integer=True)
            )  # Ensure y-ticks are integers
            plt.tight_layout()
            plt.savefig("plot.png")  # Saves as PNG
            plt.close()

        if view_seizure_length == 1 and view_soz_heatmap == 0:
            for i, day in enumerate(all_days):
                lengths = [s["duration"] for s in day_to_seizures[day]]
                for j, length in enumerate(lengths):
                    plt.bar(
                        day,
                        length,
                        bottom=bottoms[i],
                        label=f"Seizure {j+1}" if i == 0 else "",
                        color=bar_color,
                        edgecolor=edge_color,
                        linewidth=1.5,
                    )
                    bottoms[
                        i
                    ] += length  # Update the bottom for the next seizure

            plt.xlabel("Day", fontsize=14)
            plt.ylabel("Seizure Length (seconds)", fontsize=14)
            plt.title("Seizure Count and Lengths by Day", fontsize=12)
            plt.xticks(all_days, fontsize=12)
            plt.yticks(fontsize=12)
            plt.tight_layout()

            plt.close()

        elif view_seizure_length == 0 and view_soz_heatmap == 1:
            fig, ax = plt.subplots(figsize=figsize)
            # Seizure count plot
            seizure_counts = [len(day_to_seizures[day]) for day in all_days]
            bars = ax.bar(
                all_days,
                seizure_counts,
                color="lightgray",
                edgecolor="black",
                label="Number of Seizures",
            )
            bar_width = 0.6  # Full width for day bin

            # Add some spacing between seizures
            seizure_spacing = 0  # Space between seizures in days

            for i, day in enumerate(all_days):
                seizures = day_to_seizures[day]
                lengths = [1 for s in seizures]

                for j, (seizure, length) in enumerate(zip(seizures, lengths)):
                    involved_electrodes = seizure.get(
                        "electrodes", []
                    )

                    # Calculate position with spacing
                    x_pos = day + (j * seizure_spacing / len(seizures))
                    bar_width = 0.8 - (
                        seizure_spacing * (len(seizures) - 1) / len(seizures)
                    )

                    if not involved_electrodes:
                        # Default solid color if no electrodes specified
                        plt.bar(
                            x_pos,
                            length,
                            bottom=bottoms[i],
                            width=bar_width,
                            label=f"Seizure {j+1}" if i == 0 else "",
                            color=bar_color,
                            edgecolor="black",
                            linewidth=2,
                        )
                    else:
                        # Stack electrode colors horizontally
                        total_electrodes = len(involved_electrodes)
                        cumulative_length = 0

                        for k, electrode in enumerate(involved_electrodes):
                            # Get normalized color for this electrode
                            color = electrode_to_color.get(
                                electrode, bar_color
                            )
                            color = (
                                [c / 255 for c in color]
                                if isinstance(color, (list, tuple))
                                and max(color) > 1
                                else color
                            )

                            # Calculate this segment's contribution to total length
                            segment_length = length / total_electrodes

                            # Plot this segment (stacked horizontally)
                            plt.bar(
                                x_pos,
                                segment_length,
                                bottom=bottoms[i] + cumulative_length,
                                width=bar_width,
                                label=(
                                    f"{electrode}"
                                    if (i == 0 and j == 0 and k == 0)
                                    else ""
                                ),
                                color=color,
                                edgecolor="none",  # No internal edges
                                linewidth=0,
                            )

                            cumulative_length += segment_length

                        # Add border around the entire seizure
                        plt.bar(
                            x_pos,
                            length,
                            bottom=bottoms[i],
                            width=bar_width,
                            color="none",
                            edgecolor="black",
                            linewidth=4,
                        )

                    bottoms[i] += length  # Add small spacing between seizures

            plt.xlabel("Day", fontsize=14)
            plt.ylabel("Seizure Length (seconds)", fontsize=14)
            plt.title("Seizure Lengths by Day", fontsize=12)
            plt.xticks(all_days, fontsize=12)
            plt.yticks(fontsize=12)
            plt.gca().yaxis.set_major_locator(
                MaxNLocator(integer=True)
            )  # Ensure y-ticks are integers

            # Create legend showing electrode-color mapping
            handles = [
                plt.Rectangle(
                    (0, 0),
                    1,
                    1,
                    color=(
                        [c / 255 for c in electrode_to_color[elec]]
                        if max(electrode_to_color[elec]) > 1
                        else electrode_to_color[elec]
                    ),
                    label=elec,
                )
                for elec in sorted_electrodes
            ]
            plt.legend(
                handles=handles, bbox_to_anchor=(1.05, 1), loc="upper left"
            )

            plt.tight_layout()
            plt.close()

        elif view_seizure_length == 1 and view_soz_heatmap == 1:

            color_electrode_map = list(zip(colors, sorted_electrodes))

            electrode_to_color = {
                label: color for color, label in color_electrode_map
            }
            bar_width = 0.6  # Full width for day bin

            # Add some spacing between seizures
            seizure_spacing = 0  # Space between seizures in days

            for i, day in enumerate(all_days):
                seizures = day_to_seizures[day]
                lengths = [s["duration"] for s in seizures]

                for j, (seizure, length) in enumerate(zip(seizures, lengths)):
                    involved_electrodes = seizure.get(
                        "electrodes", []
                    )

                    # Calculate position with spacing
                    x_pos = day + (j * seizure_spacing / len(seizures))
                    bar_width = 0.8 - (
                        seizure_spacing * (len(seizures) - 1) / len(seizures)
                    )

                    if not involved_electrodes:
                        # Default solid color if no electrodes specified
                        plt.bar(
                            x_pos,
                            length,
                            bottom=bottoms[i],
                            width=bar_width,
                            label=f"Seizure {j+1}" if i == 0 else "",
                            color=bar_color,
                            edgecolor="black",
                            linewidth=2,
                        )
                    else:
                        # Stack electrode colors horizontally
                        total_electrodes = len(involved_electrodes)
                        cumulative_length = 0

                        for k, electrode in enumerate(involved_electrodes):
                            # Get normalized color for this electrode
                            color = electrode_to_color.get(
                                electrode, bar_color
                            )
                            color = (
                                [c / 255 for c in color]
                                if isinstance(color, (list, tuple))
                                and max(color) > 1
                                else color
                            )

                            # Calculate this segment's contribution to total length
                            segment_length = length / total_electrodes

                            # Plot this segment (stacked horizontally)
                            plt.bar(
                                x_pos,
                                segment_length,
                                bottom=bottoms[i] + cumulative_length,
                                width=bar_width,
                                label=(
                                    f"{electrode}"
                                    if (i == 0 and j == 0 and k == 0)
                                    else ""
                                ),
                                color=color,
                                edgecolor="none",  # No internal edges
                                linewidth=0,
                            )

                            cumulative_length += segment_length

                        # Add border around the entire seizure
                        plt.bar(
                            x_pos,
                            length,
                            bottom=bottoms[i],
                            width=bar_width,
                            color="none",
                            edgecolor="black",
                            linewidth=4,
                        )

                    bottoms[i] += length  # Add small spacing between seizures

            plt.xlabel("Day", fontsize=14)
            plt.ylabel("Seizure Length (seconds)", fontsize=14)
            plt.title("Seizure Lengths by Day", fontsize=12)
            plt.xticks(all_days, fontsize=12)
            plt.yticks(fontsize=12)

            # Create legend showing electrode-color mapping
            handles = [
                plt.Rectangle(
                    (0, 0),
                    1,
                    1,
                    color=(
                        [c / 255 for c in electrode_to_color[elec]]
                        if max(electrode_to_color[elec]) > 1
                        else electrode_to_color[elec]
                    ),
                    label=elec,
                )
                for elec in sorted_electrodes
            ]
            plt.legend(
                handles=handles, bbox_to_anchor=(1.05, 1), loc="upper left"
            )

            plt.tight_layout()
            plt.close()

    if screen == 2:
        # Group seizures by day
        if view_soz_heatmap == 1 and view_drug_admin == 1:
            figsize = (6, 5)
        else:
            figsize = (6, 4)
        day_to_seizures = defaultdict(list)
        for seizure in seizures:
            day_to_seizures[seizure["day"]].append(seizure)

        fig = plt.figure(figsize=figsize)

        # Normalize time to a 24-hour timeline for each day
        xticks = []  # X-axis tick positions
        xtick_labels = []  # X-axis tick labels
        label_positions = []  # To store the positions of the labels

        for day in all_days:
            day_seizures = day_to_seizures[day]
            for i, seizure in enumerate(day_seizures):
                seizure_time = datetime.strptime(
                    seizure["start_time"], "%H:%M:%S"
                ).time()
                x_value = (
                    (day - 1) * 24
                    + seizure_time.hour
                    + seizure_time.minute / 60
                    + seizure_time.second / 3600
                )
                # Offset bars horizontally if multiple seizures occur at the same time
                # Add seizure time to x-axis ticks and labels
                xticks.append(x_value)
                xtick_labels.append(
                    seizure_time.strftime("%H:%M")
                )  # Only show time, not day
                label_positions.append(x_value)
                seizure_spacing = 0
                bar_color = "skyblue"
                # start of new code

                involved_electrodes = seizure.get(
                    "electrodes", []
                )

                # Calculate position with spacing
                # x_pos = day + (j * seizure_spacing / len(seizures))
                bar_width = 0.8 - (
                    seizure_spacing * (len(seizures) - 1) / len(seizures)
                )

                if not involved_electrodes:
                    # Default solid color if no electrodes specified
                    plt.bar(
                        x_value,
                        int(seizure["duration"]),
                        bottom=bottoms[i],
                        width=bar_width,
                        label=f"Seizure {i+1}" if i == 0 else "",
                        color=bar_color,
                        edgecolor="black",
                        linewidth=2,
                    )
                else:
                    # Stack electrode colors horizontally
                    total_electrodes = len(involved_electrodes)
                    cumulative_length = 0

                    for k, electrode in enumerate(involved_electrodes):
                        # Get normalized color for this electrode
                        if view_soz_heatmap == 1:
                            color = electrode_to_color.get(
                                electrode, bar_color
                            )
                            color = (
                                [c / 255 for c in color]
                                if isinstance(color, (list, tuple))
                                and max(color) > 1
                                else color
                            )
                        else:
                            color = "skyblue"

                        # Calculate this segment's contribution to total length
                        segment_length = (
                            int(seizure["duration"]) / total_electrodes
                        )
                        bottoms = 0
                        # Plot this segment (stacked horizontally)
                        plt.bar(
                            x_value,
                            segment_length,
                            bottom=0 + cumulative_length,
                            width=bar_width,
                            label=(
                                f"{electrode}" if (i == 0 and k == 0) else ""
                            ),
                            color=color,
                            edgecolor="none",  # No internal edges
                            linewidth=0,
                        )

                        cumulative_length += segment_length
                # """
                # plt.bar(
                #     x_value,  # X-axis: normalized time across days with offset
                #     seizure['duration'],  # Y-axis: duration
                #     width=2,  # Width of bars
                #     color='blue',  # Same color for all bars
                #     align='center',
                #     label='Seizure Duration' if day == 1 and seizure == day_seizures[0] else ""  # Add label only once
                # )
                # """
                # # Add border around the entire seizure
                # """
                # plt.bar(x_value,seizure['duration'],
                #                 width=bar_width,
                #                 color='none',
                #                 edgecolor='black',
                #                 linewidth=4)
                # """
                if view_soz_heatmap == 1:
                    legend_patches = [
                        plt.Rectangle(
                            (0, 0),
                            1,
                            1,
                            color=(
                                [c / 255 for c in electrode_to_color[elec]]
                                if max(electrode_to_color[elec]) > 1
                                else electrode_to_color[elec]
                            ),
                            label=elec,
                        )
                        for elec in sorted_electrodes
                    ]
                    plt.legend(
                        handles=legend_patches,
                        title="Electrodes",
                        loc="upper left",  # Position legend at the upper left
                        bbox_to_anchor=(
                            0,
                            1.55,
                        ),  # Shift the legend to the left of the graph
                        fontsize=6,
                        ncol=len(legend_patches),
                    )
                # bottoms[i] += length  # Add small spacing between seizures

        # Adjust x-axis labels to prevent overlap
        adjusted_xticks = []
        adjusted_xtick_labels = []
        for i, (tick, label) in enumerate(zip(xticks, xtick_labels)):
            if (
                abs(xticks[i] - xticks[i - 1]) < max(xticks) / 10
            ):  # Check if labels are too close (conflict)
                xticks[i] += (
                    max(xticks) / 30
                )  # Move the current label to the right by a fixed offset (e.g., 1.0 units)

            # Place the label normally
            adjusted_xticks.append(xticks[i])
            adjusted_xtick_labels.append(label)

        # Set x-axis ticks and labels (only non-overlapping labels)
        plt.xticks(
            adjusted_xticks,
            adjusted_xtick_labels,
            rotation=45,
            ha="right",
            fontsize=8,
        )
        plt.xlabel("Time", fontsize=8)
        plt.ylabel("Seizure Duration (seconds)", fontsize=14)
        if view_drug_admin == 0:
            plt.title("Seizure Durations by Time and Day", fontsize=8)

        plt.grid(axis="y", linestyle="--", alpha=0.7)
        for day in all_days:
            day_start = (day - 1) * 24
            plt.axvline(
                x=day_start, color="black", linestyle="--", linewidth=1
            )
            # Add day label at the start of each day
            plt.text(
                day_start,
                plt.ylim()[1] * 0.95,
                f"Day {day}",
                color="black",
                ha="right",
                va="top",
                rotation=90,
                fontsize=8,
            )

        # Add a vertical dashed line to mark the end of the last day
        last_day_end = max_day * 24
        plt.axvline(x=last_day_end, color="black", linestyle="--", linewidth=1)
        plt.text(
            last_day_end,
            plt.ylim()[1] * 0.95,
            "End",
            color="black",
            ha="left",
            va="top",
            rotation=90,
            fontsize=12,
        )

        if view_drug_admin == 1:
            max_m = max(drugs, key=lambda x: int(x["dosage"]))
            max_mg = int(max_m["dosage"])
            # Plot drug administration on a secondary y-axis
            ax2 = plt.twinx()  # Create a secondary y-axis
            unique_drugs = list(
                set(drug["drug_name"] for drug in drugs)
            )  # Get unique drug names
            color_map = plt.colormaps.get_cmap(
                "tab10"
            )  # Use the recommended method to get a colormap

            # Group drugs by time to handle overlapping annotations
            time_to_drugs = []
            legend_patches = []  # To store legend patches for each drug
            for drug in drugs:
                drug_time = datetime.strptime(drug["time"], "%H:%M:%S").time()
                x_value = (
                    (drug["day"] - 1) * 24
                    + drug_time.hour
                    + drug_time.minute / 60
                    + drug_time.second / 3600
                )
                time_to_drugs.append((x_value, drug))

            # Sort the time_to_drugs dictionary by x_value (time)
            sorted_time_to_drugs = sorted(time_to_drugs, key=lambda x: x[0])

            # Initialize variables for tracking previous values
            prevXval = -float(
                "inf"
            )  # Initialize to negative infinity to ensure the first x_value is always larger
            prevYval = -float(
                "inf"
            )  # Initialize to negative infinity to ensure the first y_value is always larger
            prevPos = 0  # Initialize vertical offset for annotations
            max_drug = (
                0  # Track the maximum drug dosage for offset calculations
            )
            prevXpos = 0  # Initialize previous x_value for offset calculations
            # Iterate through sorted x_values and drugs_at_time
            for drugs in sorted_time_to_drugs:
                x_value, drug = drugs  # Unpack the tuple

                drug_time = datetime.strptime(drug["time"], "%H:%M:%S").time()
                x_value = (
                    (drug["day"] - 1) * 24
                    + drug_time.hour
                    + drug_time.minute / 60
                    + drug_time.second / 3600
                )
                # Check if labels are too close (conflict)

                drug_index = unique_drugs.index(
                    drug["drug_name"]
                )  # Get index for color mapping

                # Plot the scatter point

                # Update max_drug if the current dosage is higher
                if int(drug["dosage"]) > max_drug:
                    max_drug = int(drug["dosage"])

                if (
                    abs(int(drug["dosage"]) - prevYval)
                    < (max_mg / 10)
                ) and (abs(x_value - prevXval) < max(xticks) / 4):
                    pos = (
                        max_mg / 15
                    ) + prevPos  # Add vertical offset if labels are too close
                    prevPos = pos

                    x_value = prevXpos + max(xticks) / 100
                    prevXpos = x_value
                else:
                    pos = (
                        int(drug["dosage"]) + max_mg / 20
                    )  # Default vertical offset
                    prevPos = pos
                    prevXpos = x_value

                prevYval = int(
                    drug["dosage"]
                )  # Update previous y_value
                prevXval = (
                    (drug["day"] - 1) * 24
                    + drug_time.hour
                    + drug_time.minute / 60
                    + drug_time.second / 3600
                )  # Update previous x_value

                # Add drug name as annotation with vertical offset
                ax2.scatter(
                    x_value,  # X-axis: normalized time across days
                    int(drug["dosage"]),  # Y-axis: drug dosage
                    color=color_map(
                        drug_index / len(unique_drugs)
                    ),  # Assign unique color
                )
                # """
                # ax2.text(
                #     x_value,  # X-axis position
                #     pos,  # Y-axis position (offset vertically)
                #     drug['name'],  # Drug name
                #     color=color_map(drug_index / len(unique_drugs)),  # Use the same color as the point
                #     fontsize=10,
                #     ha='center'
                # )
                # """

            ax2.set_ylabel("Drug Dosage (mg)", fontsize=14)
            ax2.set_ylim(0, max_drug + 200)
            plt.title(
                "Seizure Durations and Drug Administration by Time and Day",
                fontsize=9,
            )
            for drug in unique_drugs:

                drug_index = unique_drugs.index(drug)

                legend_patches.append(
                    mpatches.Patch(
                        color=color_map(drug_index / len(unique_drugs)),
                        label=drug,
                    )
                )  # Add to legend

                # Add custom legend

            plt.legend(
                handles=legend_patches,
                title="Drugs",
                loc="upper left",  # Position legend at the upper left
                bbox_to_anchor=(
                    0,
                    1.35,
                ),  # Shift the legend to the left of the graph
                fontsize=6,
                ncol=len(unique_drugs),
            )

        plt.tight_layout()

        plt.close()

    if screen == 3:
        # Screen 3: Seizure onset electrodes by seizure
        electrodes = set()
        for seizure in seizures:
            electrodes.update(seizure["electrodes"])
        electrodes = sorted(list(electrodes))

        # Count the number of seizures per electrode
        electrode_counts = defaultdict(int)
        for seizure in seizures:
            for electrode in seizure["electrodes"]:
                electrode_counts[electrode] += 1

        # Prepare data for the bar graph
        electrode_names = list(electrodes)
        seizure_counts = [
            electrode_counts[electrode] for electrode in electrode_names
        ]

        # Create the bar graph
        # Create the bar graph with electrode-specific colors
        fig = plt.figure(figsize=figsize)

        # Get colors for each electrode in order
        bar_colors = [
            electrode_to_color.get(elec, "skyblue") for elec in electrode_names
        ]

        # Normalize colors if they're in 0-255 range
        normalized_colors = []
        for color in bar_colors:
            if isinstance(color, (list, tuple)) and max(color) > 1:
                normalized_colors.append([c / 255 for c in color])
            else:
                normalized_colors.append(color)

        # Plot with electrode-specific colors
        bars = plt.bar(
            electrode_names,
            seizure_counts,
            color=normalized_colors,
            edgecolor="black",
        )

        # Add black borders to each bar
        for bar in bars:
            bar.set_linewidth(1)

        plt.xlabel("Electrodes", fontsize=14)
        plt.ylabel("Number of Seizures", fontsize=14)
        plt.title(
            "Number of Seizures per Seizure Onset Electrode", fontsize=10
        )
        plt.xticks(rotation=45, ha="right", fontsize=12)
        plt.yticks(fontsize=12)
        plt.grid(axis="y", linestyle="--", alpha=0.7)
        plt.gca().yaxis.set_major_locator(MaxNLocator(integer=True))

        plt.close()
    buf = BytesIO()
    fig.savefig(buf, format="png", dpi=100, bbox_inches="tight")
    buf.seek(0)
    plt.close(fig)
    return Image.open(buf)


# # Example usage
# img = make_plot2(
#     screen=1,
#     view_seizure_length=1,
#     view_drug_admin=1,
#     view_soz_heatmap=1,
#     seizure_data=data1,
#     drug_data=data2,
# )
# display(img)
# img.save("plot_from_pil.png")  # Save using PIL


def get_colors_for_case(cases, right_count, center_count, left_count):
    """Helper to select color scheme based on case (from your original logic)"""
    if cases == 0:
        return get_red_green_blue_groups(right_count, center_count, left_count)
    elif cases == 3:
        return get_red_blue_groups(right_count, center_count)
    elif cases == 5:
        return get_red_blue_groups(center_count, left_count)
    elif cases == 6:
        return get_red_blue_groups(right_count, left_count)
    elif cases == 1:
        return get_max_separated_colors(center_count)
    elif cases == 2:
        return get_max_separated_colors(right_count)
    elif cases == 4:
        return get_max_separated_colors(left_count)
    else:
        return [(0, 0, 0, 1)] * (right_count + center_count + left_count)


import numpy as np
import colorsys
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle


def sort_electrodes(electrodes):
    # First categorize electrodes into left, right, center
    categorized = {"left": [], "right": [], "center": []}

    for electrode in electrodes:
        # Remove any trailing numbers to get the base electrode name
        base_name = "".join([c for c in electrode if not c.isdigit()])

        if base_name.startswith("L"):
            side = "left"
        elif base_name.startswith("R"):
            side = "right"
        else:
            side = "center"

        # Get the region for this electrode
        region = electrode_to_region.get(base_name, "Unknown")

        categorized[side].append((electrode, region))

    # Sort each side's electrodes by region, then by electrode name
    for side in categorized:
        categorized[side].sort(key=lambda x: (x[1], x[0]))

    # Combine in order: left, right, center
    sorted_electrodes = {
        "right": [e[0] for e in categorized["right"]],
        "center": [e[0] for e in categorized["center"]],
        "left": [e[0] for e in categorized["left"]],
    }

    return sorted_electrodes


# Process each seizure event in data1


def get_max_separated_colors(n, L=70, C=50):
    """Generate n maximally separated colors (no groups)."""
    hues = np.linspace(0, 360, n, endpoint=False)
    return [
        [
            int(x * 255)
            for x in colorsys.hls_to_rgb(hue / 360, L / 100, C / 100)
        ]
        for hue in hues
    ]


def get_red_blue_groups(n_red, n_blue, L=70, C=50):
    """Generate colors with custom counts for reddish (0°-60°) and bluish (200°-300°)."""
    hues_red = np.linspace(0, 60, n_red, endpoint=False)
    hues_blue = np.linspace(200, 300, n_blue, endpoint=False)

    colors = []
    for hue in hues_red:
        rgb = colorsys.hls_to_rgb(hue / 360, L / 100, C / 100)
        colors.append([int(x * 255) for x in rgb])
    for hue in hues_blue:
        rgb = colorsys.hls_to_rgb(hue / 360, L / 100, C / 100)
        colors.append([int(x * 255) for x in rgb])
    return colors


def get_red_green_blue_groups(n_red, n_green, n_blue, L=70, C=50):
    """Generate colors with custom counts for reddish (0°-60°), greenish (90°-180°), bluish (200°-300°)."""
    hues_red = np.linspace(0, 60, n_red, endpoint=False)
    hues_green = np.linspace(90, 180, n_green, endpoint=False)
    hues_blue = np.linspace(200, 300, n_blue, endpoint=False)

    colors = []
    for hue in hues_red:
        rgb = colorsys.hls_to_rgb(hue / 360, L / 100, C / 100)
        colors.append([int(x * 255) for x in rgb])
    for hue in hues_green:
        rgb = colorsys.hls_to_rgb(hue / 360, L / 100, C / 100)
        colors.append([int(x * 255) for x in rgb])
    for hue in hues_blue:
        rgb = colorsys.hls_to_rgb(hue / 360, L / 100, C / 100)
        colors.append([int(x * 255) for x in rgb])
    return colors


def plot_colors(colors, title):
    """Display colors with HEX codes."""
    fig, ax = plt.subplots(figsize=(10, 2))
    for i, color in enumerate(colors):
        ax.add_patch(Rectangle((i, 0), 1, 1, color=np.array(color) / 255))
        hex_color = "#%02x%02x%02x" % tuple(color)
        ax.text(
            i + 0.5,
            0.5,
            hex_color,
            ha="center",
            va="center",
            color="white" if np.mean(color) < 128 else "black",
        )
    ax.set_xlim(0, len(colors))
    ax.set_ylim(0, 1)
    ax.axis("off")
    plt.title(title)
    plt.show()


import matplotlib.pyplot as plt
import numpy as np
from collections import defaultdict
from flask import current_app

def fetch_graph_data(patient_id):
    patient = Patient.query.get(patient_id)
    if not patient:
        return [], []

    # Import psycopg2 for direct database access
    import psycopg2
    import psycopg2.extras
    
    # Get database connection parameters from the environment
    host = "db"  # Container name from docker-compose
    port = 5432  # Default PostgreSQL port
    user = "postgres"
    password = "password"
    database = "neuroclinaical"

    # Create direct connection to PostgreSQL
    conn = psycopg2.connect(
        host=host, port=port, user=user, password=password, database=database
    )
    cursor = conn.cursor(cursor_factory=psycopg2.extras.DictCursor)

    # Get drug administrations with drug information - removed the time column
    cursor.execute(
        """
        SELECT
            da.id, 
            da.drug_name,
            da.day, 
            da.dosage,
            da.time
        FROM 
            drug_administration da
        ORDER BY 
            da.day ASC
    """,
        (patient_id,),
    )

    # Fetch all results
    drugs = cursor.fetchall()

    # Convert to list of dictionaries for JSON response
    result = []
    for drug in drugs:
        """"
        drug_data = {
            "id": drug["id"],
            "name": drug["drug_name"],
            "day": drug["day"],
            "mg_administered": drug["dosage"],
            "time": drug["time"],
        }
        """
        result.append(drug)

    # Close the database connection
    cursor.close()
    conn.close()

    data = []
    for seizure in patient.seizures:
        seizure_data = {
            "id": seizure.id,
            "day": seizure.day,
            "start_time": (
                seizure.start_time.strftime("%H:%M:%S")
                if seizure.start_time
                else None
            ),
            "duration": seizure.duration,  # Already in ISO 8601 format
            "electrodes": [electrode.name for electrode in seizure.electrodes],
        }
        data.append(seizure_data)
    return data, result


def get_graphs(patient_id, graph_number):
    # REPLACE WITH PATIENT DATA !!!!!!
    data1, data2 = fetch_graph_data(patient_id)

    if not data1:
        image_path = os.path.join(os.path.dirname(__file__), "insufficientdata.png")
        image = Image.open(image_path)
        return image
    

    match graph_number:
        case 0:
            img = make_plot2(
                screen=1,
                view_seizure_length=0,
                view_drug_admin=1,
                view_soz_heatmap=0,
                seizure_data=data1,
                drug_data=data2,
            )
        case 1:
            img = make_plot2(
                screen=1,
                view_seizure_length=1,
                view_drug_admin=1,
                view_soz_heatmap=0,
                seizure_data=data1,
                drug_data=data2,
            )

        case 2:
            img = make_plot2(
                screen=1,
                view_seizure_length=0,
                view_drug_admin=1,
                view_soz_heatmap=1,
                seizure_data=data1,
                drug_data=data2,
            )

        case 3:
            img = make_plot2(
                screen=1,
                view_seizure_length=1,
                view_drug_admin=1,
                view_soz_heatmap=1,
                seizure_data=data1,
                drug_data=data2,
            )

        case 4:
            img = make_plot2(
                screen=2,
                view_seizure_length=0,
                view_drug_admin=0,
                view_soz_heatmap=0,
                seizure_data=data1,
                drug_data=data2,
            ).rotate(270, expand=True)

        case 5:
            if not data2:
                image_path = os.path.join(os.path.dirname(__file__), "insufficientdata.png")
                image = Image.open(image_path)
                return image
            img = make_plot2(
                screen=2,
                view_seizure_length=0,
                view_drug_admin=1,
                view_soz_heatmap=0,
                seizure_data=data1,
                drug_data=data2,
            ).rotate(270, expand=True)

        case 6:
            img = make_plot2(
                screen=2,
                view_seizure_length=0,
                view_drug_admin=0,
                view_soz_heatmap=1,
                seizure_data=data1,
                drug_data=data2,
            ).rotate(270, expand=True)

        case 7:
            if not data2:
                image_path = os.path.join(os.path.dirname(__file__), "insufficientdata.png")
                image = Image.open(image_path)
                return image
            img = make_plot2(
                screen=2,
                view_seizure_length=0,
                view_drug_admin=1,
                view_soz_heatmap=1,
                seizure_data=data1,
                drug_data=data2,
            ).rotate(270, expand=True)

        case 8:
            img = make_plot2(
                screen=3,
                view_seizure_length=0,
                view_drug_admin=1,
                view_soz_heatmap=1,
                seizure_data=data1,
                drug_data=data2,
            )

        case _:
            raise ValueError

    return img


# patient = "boooop"
# img0, img1, img2, img3, img4, img5, img6, img7, img8 = get_graphs(data1, data2)
# display(img0)
# display(img1)
# display(img2)
# display(img3)
# display(img4)
# display(img5)
# display(img6)
# display(img7)
# display(img8)
